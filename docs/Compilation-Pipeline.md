This document describes the compilation pipeline followed by the Elemental compiler.

# Converting a Source File into a Syntax Tree

This step can be skipped if there is already a syntax tree for the program, for example if it was generated by a frontend compiler.

1. Parse the source file into a stream of lexemes.
2. Convert the stream of lexemes into an abstract syntax tree (AST).

Note that there is no need for name resolution since names are already unambiguous and unscoped.

# Type Checking

Verify that all of the types in the program are legal.

1. Generate type constraints from the program's AST.
2. Check the type constraints.

# Optimisation

Optimise the program to improve its runtime performance.
This can be done through strong normalisation of the program's expressions.

1. Inline all the references to other expressions into exported bindings and remove all non-exported bindings by substituting the expression of referenced bindings for the reference.
2. Normalise all bindings by following a simple set of strongly normalising rewrite rules.
3. Identify and eliminate common sub-expressions (CSEs) in the exported bindings by extracting them into their own bindings.

# LLVM Generation

Generate the appropriate LLVM code for the program.

1. Convert all bindings into super combinators by introducing new bindings where necessary.
2. Generate the appropriate LLVM code for all bindings and foreign symbols.

Once the LLVM is generated, the compiler may opt to use LLVM tools to compile it into assembly or machine code.
